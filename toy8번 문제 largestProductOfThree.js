// 문제
// 정수를 요소로 갖는 배열을 입력받아 3개의 요소를 곱해 나올 수 있는 최대값을 리턴해야 합니다.

// 입력
// 인자 1 : arr
// number 타입을 요소로 갖는 임의의 배열

// 출력
// number 타입을 리턴해야 합니다.

// 주의사항
// 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.
// 배열의 요소는 음수와 0을 포함하는 정수입니다.
// 배열의 길이는 3 이상입니다.


// 내가 처음에 이해했을때는 단순히 배열의 요소를 모두 양수로 전환하여 정렬 후,
// 그냥 큰수 세개를 추려서 곱한 값을 리턴하면 될 것이라고 생각했는데 아니었음.

// 음수를 곱하더라도 음수와 음수를 곱시켜 양수를 만들 수 있다면 그게 최대 값으로 인식되는 거였음. 설령 0을 곱할지언정.

const largestProductOfThree = function (arr) {
  // 왜 굳이 slice를 해줄까... 어차피 결과 값은 같은데 일단 제거한 상태로 이렇게 작성하면
  // 오름차순 정렬이 된 배열이 sorted 변수에 저장됨.
  const sorted = arr.sort((a, b) => a - b);
  // len 변수에는 인자로 전달된 배열의 길이를 저장, 왜 저장하는지는 차차 알아보도록 하자
  const len = arr.length;
  // candi1 변수에는 정렬된 배열의 가장 끝 값과 그 다음 끝 값, 그 다음 끝 값을 곱한 후 저장한다.
  const candi1 = sorted[len - 1] * sorted[len - 2] * sorted[len - 3];
  // candi2 변수에는 배열의 가장 끝 값과 가장 앞에 두자리를 곱함.
  const candi2 = sorted[len - 1] * sorted[0] * sorted[1];
  // 그러고 이 두개의 변수에 저장된 값 중 큰 값을 리턴한다.
  return Math.max(candi1, candi2);

  // 어떻게 보면 수학적인 계산이 들어간 것인데, 정렬했을 때, 가장 큰 값이 양수로 3개면 당연히 candi1의 값이 제일 클 것이지만
  // 그렇지 않고 3개의 값 중 하나가 음수면 되려 가장 작은 값이 될 수 있는 불상사를 위해
  // candi2라는 변수를 만든 것으로 보임.
  // 일단 3개의 값이라는 것에 한번 더 생각해야할 것으로 보임. 즉, 경우의 수를 따져보자는 거임
  // 만약에 [1,2,3], [-1,2,3], [-1,-2,3], [-1,-2,-3] 일때 가장 큰수는?
  // 첫번째 거겟지
  // 결국 두개씩 짤라서 계산한 이유는 값 두개가 음수일 경우를 생각한거네.
};

let output = largestProductOfThree([2, 1, 3, 7]);
console.log(output); // --> 42 (= 2 * 3 * 7)

output = largestProductOfThree([-1, 2, -5, 7]);
console.log(output); // --> 35 (= -1 * -5 * 7)