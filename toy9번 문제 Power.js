// 내가 이해한 바로는 첫번째 파라미터로 받은 값을 두번째 파라미터로 받은 값만큼 제곱한 결과를 리턴하라는 것인데
// 결과 값이 매우 클 수 있으므로 94,906,249라는 값으로 나눈 후 나머지를 리턴하도록 결과 값을 우회하는 것임.

function power(base, exponent) {
  if (exponent === 0) return 1;
  // 당연히 제곱한 값이 0이면 결과는 1이니까 1을 리턴하도록 한 것이고,

  // parseInt 메소드 : 첫번째 파라미터(문자열)을 옵션값에 맞게 숫자형으로 바꾸어주는 것
  // 근데 여기선 half라는 값으로 굳이 제곱해야하는 값을 2로 나누어 저장하였음.
  // 왜 그런지는 아래에서 확인해보자.
  const half = parseInt(exponent / 2);

  // temp라는 변수를 만들어 재귀함수처럼 이용하는데 다만, 두번째 인자에 half값을 넣어줌.
  const temp = power(base, half);
  // 2에 4승은 결국 2에 2승 에 2에 2승을 곱한 것과 같다는 원리를 이용하여 아래 코드를 작성한 듯.
  // 값이 너무 커지는 것을 방지하기 위함인듯함.
  const result = (temp * temp) % 94906249;
  console.log(`result:${result}`)
    // result:1
    // result:9
    // result:81
    // result:59049
    // result:70159437
    // result:19334827
    // result에 저장되는 값은 위와 같은데 6번의 결과 값이 나온 것은
    // logN 시간복잡도 계산을 이용했기 때문인데, 이 방법은 경우의수를 반씩 줄여나가면서 풀게 된다.
    // 그래서 여기서 exponent의 값이 40 20 10 5 2 1 총 6번 실행되고 순서가 1부터 나온 이유는
    // 재귀함수의 특징으로 콜스택의 쌓인 순서에서 후순위부터 출력되기 때문이다.
    // 그래서 재귀 함수의 특징을 이용하려면 최종적으로 얻고자하는 값을 가장 먼저 넣어줘야한다.
    // 59049까지는 3의 10승인것처럼 정상적인 값이 나오는데
    // 처음에 내가 헷갈렸던 부분은 5번째 값인 70159437.
    // 이는 70159437이란 값이 3의 20승을 한 결과 값을 94906249로 나눈 나머지 값이어서이다.
    // 그렇다면 왜 59049까지는 3의 n제곱을 한 값 그대로 나왔는가가 헷갈릴 수 있는데
    // 이 부분은 59049까지는 94906249라는 값보다 작기 때문에 몫이 0인 상태로 59049 값 그대로가
    // 나머지이기 때문이다.
  if (exponent % 2 === 1) {
  
      return (base * result) % 94906249;
  }
  else return result;
}

let output = power(3, 40);
console.log(output); // --> 19334827